#!/usr/bin/env python3

"""54gene WGS germline pipeline

AUTHORS:
    B. Ballew
    E. Joshi

This pipeline takes demultiplexed, adapter-removed, compressed fastqs as input,
and generates QC reports, aligned BAMs, gVCFs, and multi-sample VCFs.

"""

import os
import subprocess
import pathlib
from snakemake.utils import validate
from scripts import utils

label = subprocess.check_output(["git", "describe", "--always"]).strip()
print(f"54gene WGS germline workflow {label}")


# reference the config file
configfile: "config/config.yaml"


validate(config, schema="schemas/config.schema.yaml")

# import variables from config
sampleFile = config["sampleFile"]
jobs = config["jobs"]
tempDir = config["tempDir"]
full = config["runType"]["full"]
jointgeno = config["runType"]["joint_genotyping"]
fastq_qc_only = config["runType"]["fastq_qc_only"]
global_vars = config["global_vars"]
bed = config["bed"]
max_concurrent = config["max_concurrent"]

# create temp and log dirs if needed
pathlib.Path(tempDir).mkdir(parents=True, exist_ok=True)
pathlib.Path("logs/").mkdir(parents=True, exist_ok=True)

# configure shell behavior for all rules
shell.executable("/bin/bash")
shell.prefix("set -euo pipefail; {}; ".format(global_vars))

# dict where key is readgroup, values are sample, r1 fastq, r2 fastq
sampleDict = utils.read_in_manifest(sampleFile, full, fastq_qc_only)

# list of unique sample names
SAMPLES = utils.create_samples_set(sampleDict) if full or fastq_qc_only else sampleDict.keys()

# generate list of intervals
# for the purposes of testing this method of joint calling I am
# hardcoding 50 intervals in
INTERVALS = [i for i in range(1, 51)]

# weight for trimming and fastqc rules, to avoid hitting fsx throughput limits
# The Second parameter is the desired max number of concurrently-running jobs of
# that rule.
concurrent_limit = utils.get_batch_limit_number(jobs, max_concurrent)

# chromList = utils.get_chrom_list(bed)

TARGETS = ["results/multiqc/multiqc.html"]

if full:

    TARGETS.append(expand("results/alignment_stats/{sample}.txt", sample=SAMPLES))
    TARGETS.append(expand("results/qc/contamination_check/{sample}.selfSM", sample=SAMPLES))
    TARGETS.append("results/run_summary/run_summary.html")
    TARGETS.append("results/post_qc_exclusions/samples_excluded.HC_variants.hardfiltered.vcf.gz")
    TARGETS.append("results/qc/bcftools_stats/plots/plot-vcfstats.log")

    include: "rules/track_time.smk"
    include: "rules/resources.smk"
    include: "rules/fastq_qc.smk"
    include: "rules/align.smk"
    include: "rules/HC_calling.smk"
    include: "rules/HC_joint_geno.smk"
    include: "rules/filter.smk"
    include: "rules/post_calling_qc.smk"
    include: "rules/report.smk"


elif jointgeno:

    TARGETS.append("results/run_summary/run_summary.html")
    TARGETS.append("results/post_qc_exclusions/samples_excluded.HC_variants.hardfiltered.vcf.gz")
    TARGETS.append("results/qc/bcftools_stats/plots/plot-vcfstats.log")

    include: "rules/track_time.smk"
    include: "rules/resources.smk"
    include: "rules/HC_joint_geno.smk"
    include: "rules/filter.smk"
    include: "rules/post_calling_qc.smk"
    include: "rules/report.smk"


elif fastq_qc_only:

    include: "rules/fastq_qc.smk"
    include: "rules/post_calling_qc.smk"


wildcard_constraints:
    sample="|".join(SAMPLES),
    rg="|".join(sampleDict.keys()),


rule all:
    input:
        TARGETS,
